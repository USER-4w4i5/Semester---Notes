- Continuing Relational Models

### Keys

- Keys as a Determinant
	- Key is a combination of one or more attributes that is used to identify a record related to an entity
	- based on a concept known as determination, it determines what attributes a (forgot, fill in with slides)
		- ROLLNUM in STUDENT would enable lookup of other attributes in the same record
	- Types of keys
		- **Primary Key (PK)**:
			- Uniquely identifies each row in a table.
			- Ensures data integrity by preventing duplicate or null values.
			- ADV:
				- Ensures data integrity by enforcing uniqueness.
				- Speeds up data retrieval operations, as searching by the primary key is typically faster.
		- **Foreign Key (FK)**:
			- Links a column in one table to the primary key of another table.
			- Establishes relationships between tables in a relational database.
			- ADV:
				- Maintains data integrity by enforcing referential integrity constraints.
				- Facilitates relationships between tables, enabling data consistency.
		- **Super Key**:
			- A set of one or more attributes (columns) that can uniquely identify a row in a table.
			- It may include more attributes than necessary to be a minimal unique identifier.
			- ADV:
				- Provides a way to uniquely identify rows, ensuring data integrity.
				- Useful for defining constraints and relationships.
		- **Candidate Key**:
			- A minimal super key, meaning it has the minimum number of attributes required to uniquely identify a row.
			- Often chosen as the primary key for a table.
			- ADV:
				- Speeds up searches as they are indexed and enforce uniqueness.
				- Offers flexibility in choosing the best attribute(s) for primary keys.
		- **Alternate Key**:
			- Candidate keys that are not selected as the primary key.
			- They provide an alternative means of uniquely identifying rows in a table.
			- ADV:
				- Provides additional options for unique identification.
				- Useful for different search criteria or scenarios.
		- **Composite Key**:
			- A primary key composed of two or more attributes.
			- Used when a single attribute cannot uniquely identify rows, but a combination of attributes can.
			- ADV:
				- Allows for complex, multi-attribute unique identification.
				- Enhances data integrity when a single attribute cannot guarantee uniqueness.
		- **Natural Key**:
			- A key that is based on existing, inherent attributes of the data.
			- For example, using a person's Social Security Number as a key in an employee table.
			- ADV:
				- Simplifies data entry and retrieval when using real-world identifiers.
				- Can make the database more intuitive for users.
		- **Surrogate Key**:
			- An artificial key generated by the database system, often as an auto-incrementing integer.
			- Used when there is no suitable natural key or to improve performance.
			- ADV:
				- Improves performance by avoiding the use of complex natural keys.
				- Guarantees uniqueness, even when natural keys are not available or practical.
		- **Compound Key**:
			- A key that consists of two or more attributes, but it may not be minimal like a composite key.
			- It's used to enforce uniqueness based on a combination of attributes.
			- ADV:
				- Offers a way to ensure uniqueness based on a combination of attributes.
				- Useful for scenarios where no single attribute is sufficient for unique identification.
		- **Partial Key**:
			- An attribute that is part of a candidate key but not a super key by itself.
			- It contributes to the uniqueness of a row when combined with other attributes.
			- ADV:
				- Contributes to uniqueness when combined with other attributes.
				- Can be part of a candidate key to ensure data integrity.

## Terminology

- A **Relation** is a table with attributes
	- Has Attributes as Cols
		- A degree of a table is the number of attributes it might have
	- Tuples as Rows aka entries
- Relational Model Notation aka Schema
	- R(A1,A2,A3,A4,AN)
		- R = Relation Name
		- AN = Attribute name
	- Schema = Table Definition
		- Just write the RMN (Relational Model Notation) for that relation/table
	- Snapshot = Table State
		- Data stored within the table
- NOTE: A DATABASE includes ALL relations. So Database Schema and Snapshot will include ALL relations

### Characteristics of a Relation

- **Rows (Tuples)**:
    - Each row in a relation represents a unique record or entity.
    - All rows have the same structure, meaning they contain the same attributes (columns).
- **Columns (Attributes)**:
    - Columns represent specific properties or attributes of the entities in the relation.
    - Each column has a name and a data type that defines the kind of data it can store.
- **Uniqueness of Rows**:
    - Each row in a relation must be unique, meaning there are no duplicate rows.
    - This uniqueness is enforced by the primary key constraint.
- **Ordering of Rows**:
    - The rows in a relation are not inherently ordered.
    - The order in which rows are retrieved is typically determined by the query or indexing.
- **Atomic Values**:
    - Each cell (intersection of a row and column) in a relation contains a single, indivisible value.
    - This ensures that data is stored at the most granular level.
- **No Duplicate Columns**:
    - In a relation, each column must have a distinct name.
    - Columns with the same name are not allowed.
- **Null Values**:
    - Relations can contain null values, which represent missing or unknown data.
    - Nulls are different from empty or zero values.
- **Fixed Schema**:
    - The structure of a relation, including the names and data types of its columns, is fixed and defined when the table is created.
    - Changing the schema requires altering the table.
- **No Duplicate Rows**:
    - Each row is uniquely identified by its values in the primary key columns.
    - Duplicate rows are not allowed in a relation.
- **No Specific Order of Columns**:
    - The order of columns in a relation's definition does not affect the data stored.
    - Column order is specified when creating the table but is not significant when querying the data.

### Mapping of a Regular Entity with Simple Attributes:

- In a relational database, a regular entity with simple attributes is typically represented as a single table.
- Each simple attribute corresponds to a single column in the table.
- The primary key of the table uniquely identifies each row, ensuring that there are no duplicates.
- For example, consider an entity "Student" with simple attributes "StudentID," "FirstName," "LastName," and "Age." This entity can be mapped to a table like this:

| StudentID | FirstName | LastName | Age |
| --------- | --------- | -------- | --- |
| 1 | John | Smith | 21 |
| 2 | Mary | Johnson | 20 |
| 3 | David | Lee | 22 |
- In this mapping, each row represents a student entity, and each column stores a specific attribute of the student.

### Mapping of a Regular Entity with Composite Attributes:

- When an entity has composite attributes, which are attributes made up of sub-components, a different approach is taken.
- Composite attributes are typically represented by breaking them down into individual simple attributes in the table.
- Each sub-component of the composite attribute corresponds to a separate column.
- For example, consider an entity "Address" with a composite attribute "StreetAddress" consisting of "StreetName," "StreetNumber," and "ZipCode." This entity can be mapped to a table like this:

| StreetName | StreetNumber | ZipCode |
| ---------- | ------------ | ------- |
| Elm Street | 123 | 12345 |
| Oak Avenue | 456 | 67890 |
- In this mapping, the composite attribute "StreetAddress" has been broken down into its sub-components, each with its own column.
- This approach allows for more granular storage and retrieval of data while maintaining the integrity of the composite attribute's structure.

#### Mapping of a Regular Entity with MultiValued Attributes:

- Create a separate table to represent the multi-valued attribute.
- Each row in the new table corresponds to one value of the multi-valued attribute, and it includes a foreign key that links it to the primary key of the original entity.
- For instance, consider an entity "Book" with a multi-valued attribute "Authors." In this case, you might create a separate "Authors" table and use a foreign key to connect it to the "Book" table:
**Book Table:**

|BookID|Title|ISBN|
|---|---|---|
|1|Introduction to DB|978-1234567|
|2|Data Modeling|978-9876543|

**Authors Table:**

|AuthorID|BookID|AuthorName|
|---|---|---|
|101|1|John Smith|
|102|1|Emily Brown|
|103|2|Sarah Lee|

#### Mapping of a Regular Entity with Derived Attributes:

1. **Source Data**:
    - The source data for calculating the "Age" (a derived attribute based on DOB) is the "Date of Birth" itself.
2. **Calculate the Derived Attribute**:
    - To calculate "Age" from "Date of Birth," you subtract the DOB from the current date or a reference date (e.g., the current year). The result is the person's age.
3. **Include the Derived Attribute in the Table**:
    - Add a column for "Age" in the table representing the regular entity, in this case, let's say it's a table for "Persons."

**Persons Table:**

|PersonID|FirstName|LastName|DOB|Age|
|---|---|---|---|---|
|1|John|Smith|1990-05-15|33|
|2|Emily|Johnson|1992-09-23|31|
|3|Michael|Davis|1991-03-10|32|

4. **Update the Derived Attribute**:
    - You need to ensure that the "Age" attribute is updated whenever new records are added or when the current date changes (typically once a year). You can use database triggers, scheduled tasks, or application logic to keep the "Age" attribute up-to-date.

#### Mapping of a Binary 1:m Relationship:

1. **Create Tables for Entities**:
    - Create two tables: one for the "Department" entity and another for the "Employee" entity.

**Department Table:**

|DepartmentID|DepartmentName|
|---|---|
|1|HR|
|2|IT|
|3|Sales|

**Employee Table:**

|EmployeeID|FirstName|LastName|DepartmentID|
|---|---|---|---|
|101|John|Smith|1|
|102|Emily|Johnson|2|
|103|Michael|Davis|1|
|104|Sarah|Lee|3|

2. **Establish the Relationship**:
    - In the "Employee" table, the "DepartmentID" column serves as a foreign key that references the "Department" table's primary key, "DepartmentID."
    - This foreign key establishes the one-to-many relationship. Each employee is associated with one department, while each department can have multiple employees.
	    - However note that in a partial particiaption situation
		    - The foreign key can be NULL
1. **Querying the Relationship**:
    - To retrieve employees for a specific department, you can use SQL queries with JOIN clauses. For example, to get all employees in the HR department:
2. **Maintaining Referential Integrity**:
    - Ensure that foreign key constraints are properly defined to maintain referential integrity. This prevents the creation of orphaned records or records with invalid references.
